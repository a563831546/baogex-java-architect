#<Spring 5核心原理与30个类手写实战>
##软件架构设计原则

* 开闭原则(Open-Closed Principle=OCP)
对扩展开放,对修改关闭。

* 依赖倒置原则(Dependence Inversion Principle=DIP)
高层模块不应该依赖低层模块，应依赖其抽象，抽象不依赖细节,细节应依赖抽象。(以接口为参，实现为扩展)

* 单一职责（Simple Responsibility Pinciple,SRP)
一个类、 接口或方法只负责一项职责

* 接口隔离原则（Interface Segregation Principle,ISP)
 用多个专门接口代替单一的总接口，高内聚、 低耦合。

* 迪米特原则（Law of Demeter LoD)
开闭原则的延伸，只依赖应该依赖的对象，只暴露应该暴露的方法。

* 里氏替换原则（Liskov Substitution Principle,LSP)
子类可以扩展父类的功能,但不能改变父类原有的功能。

* 合成复用原则 (Composite/Aggregate Reuse Principle,CARP)
 尽量使用对象组合(has-a)/聚合而不是继承,降低修改类对其他类的影响.
 
##设计模式  
问题1：为什么要先从设计模式开始讲?  
1. 首先可以反推出我们要学的spring5的核心肯定是用到了，不然我们也不会学
2. 一款优秀的软件架构，他必须设计优良，便于维护与扩展，要做到这些，合适的场景使用合适的设计模式，就会起到良好的效果
### 1. 工厂模式 
#### 1.1 简单工厂模式     
    它不属于GOF的一种，简单工厂故名思意就是一个专门生产对象的对象，当我们调用工厂的创建对象方法，我们不关心他的具体实现方式，我们只需传入相应的参数，就能获取到
    我们想要的对象。但这种简单的模式只适用于对象较少的，否则多了以后维护起来比较困难。
#### 1.2 工厂方法模式
    为了解决简单工厂带来的局限性,我们就可以定义一个工厂的生成对象的接口，不同对象类型可以从不同的类型工厂中生成，这样，不同的对象可以不在同一个
    工厂中生成，降低了简单工厂的臃肿， 便于相同类型对象间的管理。
#### 1.3抽象工厂模式
    为了解决工厂方法的后期雍肿的情况发生，定义一个顶级工厂接口，将工厂责任系分，抽象实现生产相同类型的对象的工厂，将责任再进一步细分。
  
### 2.单例模式 
#### 2.1 饿汉模式
    在类初始化的时候直接实例一个对象，有点效率高，缺点占内存，站着茅坑不拉屎
#### 2.2 .懒汉模式
    只有在使用时才会进行实例化，存在安全隐患，可用使用静态内部类，只有在使用该类的时候才被初始化
#### 序列化注意
    序列化时破坏了单例原则，需重写Object readResolve()方法返回单例对象
### 3. 原型模式 
####3.1 浅克隆
    只是复制引用
####3.2 深克隆
    完整复制对象属性值
### 4.代理模式
#### 4.1 静态代理和动态代理的本质区别
    1. 静态代理新增方法时代理类需同步，违反开闭原则。
    2. 动态代理实时生成，遵循开闭原则
    3. 若动态代理修改增强逻辑，结合策略模式，修改策略类即可
#### 4.2 代理模式优缺点
    优点：
       * 代理模式能将真实对象实现隔离
       * 在一定程度上降低了系统的耦合性，扩展性好。
       * 可以起到保护目标对象的作用
       * 可以增强目标对象的功能
    缺点：
       * 代理模式会造成胸痛设计中类的数量增加
       * 在客户端和目标对象中增加一个代理对象，会导致请求处理速度变慢
       * 增加了系统的复杂度
#### 4.2 策略模式   
    优点：
        1. 符合开闭原则
        2. 避免频繁的if--else
        3. 提高算法保密性
    缺点：
        1. 客户端必须知道所有策略，自行决定
        2. 代码中太多策略类提高维护性
#### 4.2 模板模式
    优点：
        1. 相同逻辑放父类，提高代码的复用性
        2. 不同的放子类，提高扩展性
        3. 把不变的放在父类，提高复用性的同时也满足开闭原则
    缺点：
        1. 每个类都要一个子类来实现，导致类的数量增加
        2. 类数量的增加间接地增加了复杂度
    
