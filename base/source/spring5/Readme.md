#<Spring 5核心原理与30个类手写实战>
##软件架构设计原则

* 开闭原则(Open-Closed Principle=OCP)
对扩展开放,对修改关闭。

* 依赖倒置原则(Dependence Inversion Principle=DIP)
高层模块不应该依赖低层模块，应依赖其抽象，抽象不依赖细节,细节应依赖抽象。(以接口为参，实现为扩展)

* 单一职责（Simple Responsibility Pinciple,SRP)
一个类、 接口或方法只负责一项职责

* 接口隔离原则（Interface Segregation Principle,ISP)
 用多个专门接口代替单一的总接口，高内聚、 低耦合。

* 迪米特原则（Law of Demeter LoD)
开闭原则的延伸，只依赖应该依赖的对象，只暴露应该暴露的方法。

* 里氏替换原则（Liskov Substitution Principle,LSP)
子类可以扩展父类的功能,但不能改变父类原有的功能。

* 合成复用原则 (Composite/Aggregate Reuse Principle,CARP)
 尽量使用对象组合(has-a)/聚合而不是继承,降低修改类对其他类的影响.
 
##设计模式  
问题1：为什么要先从设计模式开始讲?  
1. 首先可以反推出我们要学的spring5的核心肯定是用到了，不然我们也不会学
2. 一款优秀的软件架构，他必须设计优良，便于维护与扩展，要做到这些，合适的场景使用合适的设计模式，就会起到良好的效果
### 1. 工厂模式 
#### 1.1 简单工厂模式     
    它不属于GOF的一种，简单工厂故名思意就是一个专门生产对象的对象，当我们调用工厂的创建对象方法，我们不关心他的具体实现方式，我们只需传入相应的参数，就能获取到
    我们想要的对象。但这种简单的模式只适用于对象较少的，否则多了以后维护起来比较困难。
#### 1.2 工厂方法模式
    为了解决简单工厂带来的局限性,我们就可以定义一个工厂的生成对象的接口，不同对象类型可以从不同的类型工厂中生成，这样，不同的对象可以不在同一个
    工厂中生成，降低了简单工厂的臃肿， 便于相同类型对象间的管理。
#### 1.3抽象工厂模式
    为了解决工厂方法的后期雍肿的情况发生，定义一个顶级工厂接口，将工厂责任系分，抽象实现生产相同类型的对象的工厂，将责任再进一步细分。
  
### 2.单例模式 
#### 2.1 饿汉模式
    在类初始化的时候直接实例一个对象，有点效率高，缺点占内存，站着茅坑不拉屎
#### 2.2 .懒汉模式
    只有在使用时才会进行实例化，存在安全隐患，可用使用静态内部类，只有在使用该类的时候才被初始化
#### 序列化注意
    序列化时破坏了单例原则，需重写Object readResolve()方法返回单例对象
### 3. 原型模式
####3.1 浅克隆     
    只是复制引用
####3.2 深克隆     
    完整复制对象属性值
